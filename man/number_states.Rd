% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/number_states.R
\name{number_states}
\alias{number_states}
\title{Number non-consecutive state occurrences}
\usage{
number_states(
  dataset,
  state.colname,
  colname.extension = ".count",
  use.original.state = TRUE
)
}
\arguments{
\item{dataset}{A \code{data.frame} with a state column.}

\item{state.colname}{Column name that contains the state. Expects a \code{symbol}.
Needs to be part of the \code{dataset}. Can be of any type, but \code{character} and
\code{factor} make the most sense.}

\item{colname.extension}{The extension that is added to the state name to
create the new column. Defaults to \code{".count"}.}

\item{use.original.state}{Logical, whether the original state should be part
of the output column.}
}
\value{
The input \code{dataset} with an additional column that counts the
occurrences of each state. The new column will of type \code{character} if
\code{use.original.state = TRUE} and \code{integer} otherwise.
}
\description{
\code{\link[=number_states]{number_states()}} creates a new column in a dataset that takes a state column
and assigns a count value to each state, rising every time a state is
replaced by another state. E.g., a column with the states "day" and "night"
will produce a column indicating whether this is "day 1", "day 2", and so
forth, as will the "night" state with "night 1", "night 2", etc. Grouping
within the input dataset is respected, i.e., the count will reset for each
group.
}
\details{
The state column is not limited to two states, but can have as many states as
needed. Also, it does not matter in which time frames these states change, so
they do not necessarily conform to a 24-hour day. \code{NA} values will be treated
as their own state.

Gaps in the data can lead to non-sensible outcomes, e.g. if there is no
in-between state/observation between a day state at "18:00:00" and a day
state at "6:00:00" - this would be counted as \verb{day 1} still. In these cases,
the \code{\link[=gap_handler]{gap_handler()}} function can be useful to a priori add observations.
}
\examples{
dataset <- tibble::tibble(
 state =
 c("day", "day", "day", "night", "night", "day", "day", "night",
 "night", "night", "day", "night")
 )
number_states(dataset, state)
number_states(dataset, state, use.original.state = FALSE)

#example with photoperiods, calculating the mean values for each day and night
coordinates <- c(48.52, 9.06)
sample.data.environment |>
  add_photoperiod(coordinates) |>
  number_states(photoperiod.state) |>
  dplyr::group_by(photoperiod.state.count, .add = TRUE) |>
  dplyr::summarize(mean_MEDI = mean(MEDI)) |>
  tail(13)

}
